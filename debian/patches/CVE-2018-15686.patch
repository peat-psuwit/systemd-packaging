Description: core: when deserializing state always use read_line(…, LONG_LINE_MAX, …)

 This should be much better than fgets(), as we can read substantially
 longer lines and overly long lines result in proper errors.

 Fixes a vulnerability discovered by Jann Horn at Google.

 CVE-2018-15686

Origin: upstream, https://github.com/poettering/systemd/commit/8948b3415d762245ebf5e19d80b97d4d8cc208c1
Bug-Ubuntu: https://launchpad.net/bugs/1796402

--- a/src/core/job.c
+++ b/src/core/job.c
@@ -27,6 +27,7 @@
 #include "dbus-job.h"
 #include "dbus.h"
 #include "escape.h"
+#include "fileio.h"
 #include "job.h"
 #include "log.h"
 #include "macro.h"
@@ -1014,23 +1015,25 @@
 }

 int job_deserialize(Job *j, FILE *f, FDSet *fds) {
+        int r;
+
         assert(j);

         for (;;) {
-                char line[LINE_MAX], *l, *v;
+                _cleanup_free_ char *line = NULL;
+                char *l, *v;
                 size_t k;

-                if (!fgets(line, sizeof(line), f)) {
-                        if (feof(f))
-                                return 0;
-                        return -errno;
-                }
+                r = read_line(f, LONG_LINE_MAX, &line);
+                if (r < 0)
+                        return log_error_errno(r, "Failed to read serialization line: %m");
+                if (r == 0)
+                        return 0;

-                char_array_0(line);
                 l = strstrip(line);

                 /* End marker */
-                if (l[0] == 0)
+                if (isempty(l))
                         return 0;

                 k = strcspn(l, "=");
--- a/src/core/manager.c
+++ b/src/core/manager.c
@@ -2335,21 +2335,19 @@
         m->n_reloading ++;

         for (;;) {
-                char line[LINE_MAX], *l;
-
-                if (!fgets(line, sizeof(line), f)) {
-                        if (feof(f))
-                                r = 0;
-                        else
-                                r = -errno;
+                _cleanup_free_ char *line = NULL;
+                 const char *l;

+                r = read_line(f, LONG_LINE_MAX, &line);
+                if (r < 0) {
+                        r = log_error_errno(r, "Failed to read serialization line: %m");
                         goto finish;
                 }
+                if (r == 0)
+                        break;

-                char_array_0(line);
                 l = strstrip(line);
-
-                if (l[0] == 0)
+                if (isempty(l)) /* end marker */
                         break;

                 if (startswith(l, "current-job-id=")) {
@@ -2471,20 +2469,17 @@
         }

         for (;;) {
+                _cleanup_free_ char *name = NULL;
                 Unit *u;
-                char name[UNIT_NAME_MAX+2];

                 /* Start marker */
-                if (!fgets(name, sizeof(name), f)) {
-                        if (feof(f))
-                                r = 0;
-                        else
-                                r = -errno;
-
+                r = read_line(f, LONG_LINE_MAX, &name);
+                if (r < 0) {
+                        r = log_error_errno(r, "Failed to read serialization line: %m");
                         goto finish;
                 }
-
-                char_array_0(name);
+                if (r == 0)
+                        break;

                 r = manager_load_unit(m, strstrip(name), NULL, NULL, &u);
                 if (r < 0)
@@ -2496,9 +2491,6 @@
         }

 finish:
-        if (ferror(f))
-                r = -EIO;
-
         assert(m->n_reloading > 0);
         m->n_reloading --;

--- a/src/core/unit.c
+++ b/src/core/unit.c
@@ -2687,20 +2687,18 @@
                 rt = (ExecRuntime**) ((uint8_t*) u + offset);

         for (;;) {
-                char line[LINE_MAX], *l, *v;
+                _cleanup_free_ char *line = NULL;
+                char *l, *v;
                 size_t k;

-                if (!fgets(line, sizeof(line), f)) {
-                        if (feof(f))
-                                return 0;
-                        return -errno;
-                }
+                r = read_line(f, LONG_LINE_MAX, &line);
+                if (r < 0)
+                        return log_error_errno(r, "Failed to read serialization line: %m");
+                if (r == 0) /* eof */
+                        break;

-                char_array_0(line);
                 l = strstrip(line);
-
-                /* End marker */
-                if (isempty(l))
+                if (isempty(l)) /* End marker */
                         break;

                 k = strcspn(l, "=");
--- a/src/basic/fileio.c
+++ b/src/basic/fileio.c
@@ -1278,3 +1278,75 @@

         return fputs(s, f);
 }
+
+DEFINE_TRIVIAL_CLEANUP_FUNC(FILE*, funlockfile);
+
+int read_line(FILE *f, size_t limit, char **ret) {
+        _cleanup_free_ char *buffer = NULL;
+        size_t n = 0, allocated = 0, count = 0;
+
+        assert(f);
+
+        /* Something like a bounded version of getline().
+         *
+         * Considers EOF, \n and \0 end of line delimiters, and does not include these delimiters in the string
+         * returned.
+         *
+         * Returns the number of bytes read from the files (i.e. including delimiters — this hence usually differs from
+         * the number of characters in the returned string). When EOF is hit, 0 is returned.
+         *
+         * The input parameter limit is the maximum numbers of characters in the returned string, i.e. excluding
+         * delimiters. If the limit is hit we fail and return -ENOBUFS.
+         *
+         * If a line shall be skipped ret may be initialized as NULL. */
+
+        if (ret) {
+                if (!GREEDY_REALLOC(buffer, allocated, 1))
+                        return -ENOMEM;
+        }
+
+        {
+                _unused_ _cleanup_(funlockfilep) FILE *flocked = f;
+                flockfile(f);
+
+                for (;;) {
+                        int c;
+
+                        if (n >= limit)
+                                return -ENOBUFS;
+
+                        errno = 0;
+                        c = fgetc_unlocked(f);
+                        if (c == EOF) {
+                                /* if we read an error, and have no data to return, then propagate the error */
+                                if (ferror_unlocked(f) && n == 0)
+                                        return errno > 0 ? -errno : -EIO;
+
+                                break;
+                        }
+
+                        count++;
+
+                        if (IN_SET(c, '\n', 0)) /* Reached a delimiter */
+                                break;
+
+                        if (ret) {
+                                if (!GREEDY_REALLOC(buffer, allocated, n + 2))
+                                        return -ENOMEM;
+
+                                buffer[n] = (char) c;
+                        }
+
+                        n++;
+                }
+        }
+
+        if (ret) {
+                buffer[n] = 0;
+
+                *ret = buffer;
+                buffer = NULL;
+        }
+
+        return (int) count;
+}
--- a/src/basic/fileio.h
+++ b/src/basic/fileio.h
@@ -82,3 +82,5 @@
 int read_timestamp_file(const char *fn, usec_t *ret);

 int fputs_with_space(FILE *f, const char *s, const char *separator, bool *space);
+
+int read_line(FILE *f, size_t limit, char **ret);
--- a/src/basic/def.h
+++ b/src/basic/def.h
@@ -90,3 +90,5 @@
         "/usr/local/lib/" n "\0" \
         "/usr/lib/" n "\0" \
         _CONF_PATHS_SPLIT_USR(n)
+
+#define LONG_LINE_MAX (1U*1024U*1024U)
